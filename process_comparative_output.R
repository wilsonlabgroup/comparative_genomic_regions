#!/usr/bin/env Rscript

# This script is used to process comparative query outputs and overlaps them with genomic regions of interests from other species.

# processes outputs from Ensembl compara, halLiftOver and UCSC liftover

# reports conservation level in three modes
### Legacy: liftover from query species to anchor species to overlap with anchor peaks
### Strict: liftover and overlap from both perspectives
### Permissive: liftover and overlap from either perspective

# Paralogs:
### only consider one to one match
### considers peak overlaps with any paralogs

# update 2022.11 Huayun
# minor change in associating the conservation statues vector "out" with original peaks. Now matches by peak name 
# minor change added parallel support
# for 4 species, ~50K peaks each, runs with 12 cores, uses ~10G ~3mins

# update 2023.01 Huayun
# add options for peak overlapping modes
# make script work for both compara and halLiftover output

# TODO:
# deal with paralogs
# implement peak overlap by percentage -- for hal liftover also consider proportion of peak lifted over? -- preserve lifted regions in intermediate output?
# filter out fragmented alignment? -- solved by HALPER

suppressPackageStartupMessages(library(GenomicRanges))
suppressPackageStartupMessages(library(tidyverse))
suppressPackageStartupMessages(library(optparse))
suppressPackageStartupMessages(library(parallel))


# parse arguments ---------------------------------------------------------
option_list <- list(
  make_option(c("-i", "--input-file"), 
              help="Input file specifiying species, path to compara output, and path to peak files "),
  make_option(c("-f", "--factor"),  
                help="The TF/factor being analyzed"),
  make_option(c("-m","--maxmin"), default = "0:1", help="Maxgap:Mininum overlap between orthologous regions and peaks, in bp [default %(default)s]"),
  make_option(c("-s", "--stitchbp"),type="integer", default=2, 
              help="Stitching orthologous regions within how many bps [default %(default)s]"),
  make_option("--mode", default = "L", help= "matchType: one of L|P|S (P by default) for Legacy, Permissive, or Strict matching"),
  make_option(c("-p", "--return-num-paralogs"), action = "store_true", default = FALSE,
              help = "If to return the number of paralogous regions"),
  make_option(c("-t", "--threads"), default = 4,
              help = "number of threads to use"),
  make_option("--type", default = "hal", help = "Which alignment was used to generate the orthologs regions. Choose from 'hal','compara', and 'ucsc'. Default is 'hal'"),
  make_option("--label",default = "", help = "Additional text labels to add to output files")
)

opt_parser <- OptionParser(option_list=option_list)
args <- parse_args(opt_parser)


input_file = args$`input-file`
tf = args$factor
stitchbp = args$stitchbp ## Compara often reports regions with small gaps (1bp). Regions separated by <= stitchbp will be merged
maxgap = as.numeric(unlist(strsplit(args$maxmin, ":"))[1])
minovl = as.numeric(unlist(strsplit(args$maxmin, ":"))[2])

threads = args$threads

return_num_paralogs <- args$return_num_paralogs
return_num_paralogs <- FALSE

matchType <- args$mode

if (matchType == "L"){
  print("matchType specified as 'L': Matching in (L)egacy mode")
} else if (matchType == "P"){
  print("matchType specified as 'P': Matching in (P)ermissive mode")
} else if (matchType == "S"){
  print("matchType specified as 'S': Matching in (S)trict mode")
} else {
  stop("unrecognized matchType != [L|P|S]")
}

alignment_type <- args$type
if(!alignment_type %in% c("hal","compara","ucsc")){
  stop(paste0("unrecognized alignment type ", alignment_type, "; choose from hal, compara, and ucsc"))
}

# for testing -------------------------------------------------------------
# input_file <- "/mnt/mdwilson/huayun/others/hal_vs_epo/hal_zoonomia/rela/rscript_input.txt"
# alignment_type <- "hal"
# 
# tf <- "rela"
# stitchbp <- 2
# maxgap <- 1
# minovl <- 0
# threads <- 2
# return_num_paralogs <- F
# matchType <- "S"
#  
# input_file <- "/mnt/mdwilson/huayun/collabs/rela/rela_compara_102/rela/rscript_input.txt"
# alignment_type <- "compara"
# 
# input_file <- "/mnt/mdwilson/huayun/others/hal_vs_epo/liftover/rela_rscript_input.txt"
# alignment_type <- "ucsc"

# Output argument 
print(args)


# read input file ---------------------------------------------------
print(input_file)
file_table <- read.table(input_file, stringsAsFactors=FALSE) ## Read in table generated by wrapper
# depends on which alignment was used, set colnames for input file and extract species
if(alignment_type == "compara"){
  colnames(file_table) <- c("target_species","lifted_res","original_peak")
} else{
  colnames(file_table) <- c("target_species", "other_species", "lifted_res", "original_peak")
}

species_list <- unique(file_table$target_species)


# for testing
# file_table$lifted_res <- gsub("home/huayun|hpf/largeprojects","mnt", file_table$lifted_res)
# file_table$original_peak <- gsub("home/huayun|hpf/largeprojects","mnt", file_table$original_peak)

# functions ---------------------------------------------------------------
find_common <- function(x, y){
  # given two strings containing peaks separated by ;, find intersecting peaks
  if(anyNA(c(x,y))){
    return(NA)
  }else{
  x_list <- unlist(strsplit(x, ";"))
  y_list <- unlist(strsplit(y, ";"))
  return(paste(intersect(x_list, y_list), collapse = ";"))
  }
}

find_union <- function(x, y){
  # given two strings containing peaks separated by ;, find a union of peaks. If both NA, return NA
  if(is.na(x) & is.na(y)){
    return(NA)
  } else{
    x_list <- unlist(strsplit(x, ";"))
    y_list <- unlist(strsplit(y, ";"))
    return(paste(na.omit(unique(union(x_list, y_list))), collapse = ";"))
  }
}

regions_to_grlist_hal <- function(region_df, label){
  region_gr <- makeGRangesFromDataFrame(region_df, keep.extra.columns = T)
  # split into list by anchor peak and stitch regions next to each other
  region_gr_list <- GenomicRanges::reduce(split(region_gr, region_gr$anchor_oriPeak, drop = F), min.gapwidth = stitchbp)
  region_gr_list <- region_gr_list[unique(region_gr$anchor_oriPeak)]
  
  # flatten the list, add query species peak names and resplit into lists
  region_gr_unlisted <- unlist(region_gr_list)
  mcols(region_gr_unlisted)[paste0(label,"_liftedGr")] <- with(region_gr_unlisted, paste0(label,".",seqnames, ":", start, "-", end))
  region_gr_list <- split(region_gr_unlisted, names(region_gr_unlisted), drop = F)
  
  # out vector contains num of paralogs, report here to be consistent with
  out <- elementNROWS(region_gr_list)
  
  return(list("ortho_regions" = region_gr_list, "out" = out))
}


regions_to_grlist_compara <- function(region_df){
  # Function to parse compara results and summarize the returned region types
  # Parse compara output string to a dataframe
  region_df <- region_df %>% 
    setNames(c("anchor_oriPeak", "other")) %>% 
    mutate(other = strsplit(as.character(other), '\\:')) %>% 
    unnest_legacy(other) %>% 
    separate(other, into = c('species', 'seqnames', "start", "end"), sep = '\\.') %>% 
    mutate(width = as.numeric(start) - as.numeric(end))
  
  # A vector to store the types of orthologous regions
  out <- region_df %>% 
    group_by(anchor_oriPeak) %>% 
    summarise(num_paralogs = as.character(length(species)), width = sum(width), species = paste0(unique(species))) %>% 
    mutate(out = case_when(species == "none" ~ "X",
                           width == 1 & species != "none" ~ "G",
                           TRUE ~ num_paralogs)) %>% 
    dplyr::select(anchor_oriPeak, out) %>% 
    deframe()
  
  # Convert df to granges object  and further split it into a list for fast processing
  region_gr <- makeGRangesFromDataFrame(region_df, keep.extra.columns = T)
  region_gr_list <- GenomicRanges::reduce(split(region_gr, region_gr$anchor_oriPeak, drop = F), min.gapwidth = stitchbp)
  region_gr_list <- region_gr_list[unique(region_gr$anchor_oriPeak)] # reorder
  
  # Get region length after stitching and correct the output
  num_paralogs <- elementNROWS(region_gr_list)
  multi_index <- which(!out %in% c("1", "X", "G"))
  out[multi_index] <- num_paralogs[multi_index]
  
  # reorder out 
  out <- out[unique(region_gr$anchor_oriPeak)]
  
  return(list("ortho_regions" = region_gr_list, "out" = out))
}


# Get a list of GRanges for original peaks --------------------------------

original_peaks <- lapply(species_list, function(anchor_species){ ## Read in original peak file. Order is the same as in the compara_regions file
  print(paste0("Reading original peaks for: ", anchor_species))
  peaks <- read.table(unique(subset(file_table, target_species == anchor_species)$original_peak), col.names = c("seqnames", "start", "end", "oriPeak")) 
  if(alignment_type == "hal"){
    peaks <- peaks[-1,]
    peaks$oriPeak <- with(peaks, paste0(seqnames,":", start, "-", end))
  } else if(alignment_type == "compara"){
    # if compara, make original peaks into chr.start.end format to match with compara output style
    peaks$oriPeak <- with(peaks, paste0(seqnames,".", start, ".", end))
  } else if(alignment_type == "ucsc"){
    # if ucsc, assumes peak name is the forth column, preserve peaknames
    colnames(peaks)[colnames(peaks) == "oriPeak"] <- "peakname"
    peaks$oriPeak <- with(peaks, paste0(seqnames,":", start, "-", end))
  }
  peaks$oriPeak <- paste0(anchor_species, ".", peaks$oriPeak)
  peak.ranges <- makeGRangesFromDataFrame(peaks, keep.extra.columns = T)
})
names(original_peaks) <- species_list

# Get a list of compara results.-------------------------------------------------------------------------
# For each species, compara results for other species are stored as lists of GrangesList, which allows multiple hits to be stored. 
# Meanwhile, the EPO outputs are classified into :
# X : EPO returned NA
# D : EPO returned a region of 0 width
# 1:n : number of regions returned by EPO
# The GRangesList and EPO output coding are returned as a named list for easy access 

read_res_from_compara <- function(anchor_species){
  # this function reads output of compara when peaks from the anchor species is lifted over to other speices.
  # only one output file per anchor species
  print(paste("Processing Compara Regions for:", anchor_species))
  anchor_species_compara <- read.table(subset(file_table, target_species == anchor_species)$lifted_res, comment.char="",header=T, stringsAsFactors=FALSE)
  # set all NAs to a dummy region 
  anchor_species_compara[is.na(anchor_species_compara)] <- "none.0.1.0"
  
  # Process all the compara results for the anchor species
  compara_species_process_out <- mclapply(species_list, function(query_species){
    print(query_species)
    other_species_aligned <- anchor_species_compara[, c(1, which(colnames(anchor_species_compara) == query_species))]
    return(regions_to_grlist_compara(other_species_aligned))
  }, mc.cores = threads)
  #compara_species_grs <- lapply(compara_species_process_out, "[[", 1)
  names(compara_species_process_out) <- species_list
  return(compara_species_process_out)
}

read_res_from_hal <- function(anchor_species){
  # this function reads output of hal_gene_liftover.py when peaks from the anchor species is lifted over to other species
  # one output file per other species
  print(paste("Processing halLiftover Regions for:", anchor_species))
  other_species_list <- species_list[species_list != anchor_species]
  
  # Process all the liftover results for the anchor species
  hal_other_species_process_out <- lapply(other_species_list, function(query_species){
    print(query_species)
    liftover_file <- subset(file_table, target_species == anchor_species & other_species == query_species)$lifted_res
    if(!file.exists(liftover_file)){
      stop(paste("liftover result file", liftover_file, "does not exist"))
    } else{
      lift <- read.table(liftover_file, header = T, stringsAsFactors = F, as.is = T) %>%
        dplyr::select(seqnames = dest_chr, start = dest_start, end = dest_end, src_chr, src_start, src_end) #%>% 
        #right_join(as.data.frame(original_peaks[[anchor_species]]) %>% dplyr::select(src_chr=seqnames, src_start = start, src_end = end))
      lift$anchor_oriPeak <- paste0(anchor_species, ".", lift$src_chr,":", lift$src_start,"-", lift$src_end)
      return(regions_to_grlist_hal(lift, query_species))
    }
  })
  names(hal_other_species_process_out) <- other_species_list
  return(hal_other_species_process_out)
}

read_res_from_ucsc <- function(anchor_species){
  # this function reads output of UCSC liftover or HALPER when peaks from the anchor species is lifted over to other species
  # one output file per other species
  print(paste("Processing UCSC/HALPER liftover Regions for:", anchor_species))
  other_species_list <- species_list[species_list != anchor_species]
  
  # Process all the liftover results for the anchor species
  hal_other_species_process_out <- lapply(other_species_list, function(query_species){
    print(query_species)
    liftover_file <- subset(file_table, target_species == anchor_species & other_species == query_species)$lifted_res
    if(!file.exists(liftover_file)){
      stop(paste("liftover result file", liftover_file, "does not exist"))
    } else{
      anchor_peaks <- as.data.frame(original_peaks[[anchor_species]]) %>% 
        dplyr::select(peakname, anchor_oriPeak = oriPeak)
      lift <- read.table(liftover_file, stringsAsFactors = F, as.is = T)[,1:4] %>% 
        setNames(c("seqnames","start","end","peakname")) %>%
        left_join(anchor_peaks, by = "peakname") %>% 
        dplyr::select(-peakname)
  
      return(regions_to_grlist_hal(lift, query_species))
    }
  })
  names(hal_other_species_process_out) <- other_species_list
  return(hal_other_species_process_out)
}



  # read peak liftover results 
if(alignment_type == "compara"){
  lifted_list <- mclapply(species_list, read_res_from_compara, mc.cores = threads) 
} else if(alignment_type == "hal"){
  lifted_list <- mclapply(species_list, read_res_from_hal, mc.cores = threads) 
} else if(alignment_type == "ucsc"){
    lifted_list <- mclapply(species_list, read_res_from_ucsc, mc.cores = threads) 
}

names(lifted_list) <- species_list


# Overlap orthologous regions and peaks -------------------------------------------------------------

match_pair_species <- function(anchor_species, query_species){
  print(paste("Matching regions between: ", anchor_species, query_species))
  
  anchor_species_ori_peaks <- original_peaks[[anchor_species]]
  anchor_species_compara_regions <- lifted_list[[anchor_species]][[query_species]]$ortho_regions
  
  query_species_ori_peaks <- original_peaks[[query_species]]
  query_species_compara_regions <- lifted_list[[query_species]][[anchor_species]]$ortho_regions
  
  # overlaps between anchor species lifted to query, and query peaks
  anchor_lift2_other <- findOverlaps(anchor_species_compara_regions, query_species_ori_peaks, maxgap=maxgap, minoverlap=minovl)
  
  # overlaps between query species lifted to anchor, and anchor peaks
  other_lift2_anchor <- findOverlaps(anchor_species_ori_peaks, query_species_compara_regions, maxgap=maxgap, minoverlap=minovl)
  
  # collect overlap results per peak
  # from the 'anchor_lift2_others' perspective
  con_from_anchor <- data.frame(anchor_peak_from_anchor = names(anchor_species_compara_regions)[from(anchor_lift2_other)],
                                query_peak_from_anchor = query_species_ori_peaks$oriPeak[to(anchor_lift2_other)]) %>% group_by(anchor_peak_from_anchor) %>% 
    summarise(query_peaks_from_anchor = paste(sort(unique(query_peak_from_anchor)), collapse = ";"),
              n_from_anchor = n())
  
  # from the 'query lifted2 anchor' perspective 
  con_from_query <- data.frame(anchor_peak_from_query = anchor_species_ori_peaks$oriPeak[from(other_lift2_anchor)],
                               query_peak_from_query = names(query_species_compara_regions)[to(other_lift2_anchor)]) %>% group_by(anchor_peak_from_query) %>% 
    summarise(query_peaks_from_query = paste(sort(unique(query_peak_from_query)), collapse = ";"),                               n_from_query = n())
  
  # merge results with anchor species original peaks 
  all_con <- data.frame(oriPeak = anchor_species_ori_peaks$oriPeak) %>% 
    left_join(con_from_anchor, by = c("oriPeak" = "anchor_peak_from_anchor")) %>% 
    left_join(con_from_query, by = c("oriPeak" = "anchor_peak_from_query")) %>% 
    unique()
  
  # find common query peaks that anchor peaks map to 
  all_con$common <- apply(all_con,1, function(x) find_common(x["query_peaks_from_query"], x["query_peaks_from_anchor"]))
  all_con$union <- apply(all_con,1, function(x) find_union(x["query_peaks_from_query"], x["query_peaks_from_anchor"]))
  
  # retrieve the final set of conserved peaks based on matchType
  para_col_name <- paste0("num_paralogs_", query_species)
  if(matchType == "L"){
    conserved_pks <- all_con %>% 
      #mutate(!!para_col_name != n_from_query) %>% 
      dplyr::select(oriPeak,!!query_species := query_peaks_from_query, !!para_col_name := n_from_query)
      
  } else if(matchType == "P"){
    conserved_pks <- all_con %>% 
      mutate(!!para_col_name := str_count(union,query_species)) %>% 
      dplyr::select(oriPeak, !!query_species := union, !!para_col_name) 
  } else{
    # strict mode
    conserved_pks <- all_con %>% 
    mutate(!!para_col_name := str_count(common,query_species)) %>% 
      dplyr::select(oriPeak, !!query_species := common, !!para_col_name) 
  }
  
  # construct the string encoding conservation status
  
 if(alignment_type == "hal"|alignment_type == "ucsc"){
   # if based on hal alignment, initiate an empty string. Peaks with ortho region in query species are labeled with 0, without ortho regions: X
   conserved_pks$out <- "X"
   conserved_pks$out[conserved_pks$oriPeak %in% names(lifted_list[[anchor_species]][[query_species]]$ortho_regions)] <- "0"
   conserved_pks$out[conserved_pks[,para_col_name] >=1] <- "1"
   colnames(conserved_pks)[colnames(conserved_pks) == "out"] <- paste0(query_species, "_conStatus")
  # species_con_out <- conserved_pks
 } else if(alignment_type == "compara"){
   # For the compara output summary of anchor species projected to other species, saving only X and Gs, and set everything else to 0, meaning EPO alignment found 
   #out <- lifted_list[[anchor_species]][[query_species]]$out
   out <- lifted_list[[anchor_species]][[query_species]]$out
   out[!out %in% c("X", "G")] <- "0"
   # If the "lifted over" regions overlap with anchor species peaks, label it with 1.
   temp <- conserved_pks[!is.na(conserved_pks[, query_species]), "oriPeak"]
   out[temp] <- "1"
   
   conserved_pks[, paste0(query_species, "_conStatus")] <- out[conserved_pks$oriPeak]

 }
  return(conserved_pks)
}


compara_matched_list <- mclapply(species_list, function(anchor_species){
  print(paste("Processing region match for:", anchor_species))
  
  if(alignment_type != "compara"){
    other_species_list <- species_list[species_list != anchor_species]
  } else{
    other_species_list <- species_list
  }
  # process each "other species"
  match_one_species <- mclapply(other_species_list, function(query_species) match_pair_species(anchor_species, query_species), mc.cores = threads)
  match_one_species_out <- match_one_species %>% 
    purrr::reduce(left_join, by = "oriPeak") %>% 
    unite("conservation", ends_with("_conStatus"), sep = "") %>% 
    separate(oriPeak, sep = "([\\.\\:\\-])", into = c(NA, "seqnames", "start", "end")) %>% 
    dplyr::select(seqnames, start, end, conservation, !!other_species_list, everything())
  
  if(!return_num_paralogs){
    match_one_species_out <- match_one_species_out %>% 
      dplyr::select(-starts_with("num_paralogs"))
  }
  
  write.table(x=match_one_species_out,
              file=paste0(tf,"_max",maxgap,"min",minovl,"_peakConservation_", anchor_species,"_",alignment_type,"_",matchType, args$label,".txt"),
              row.names=F, quote=F, sep="\t")
  
  return(match_one_species_out)
}, mc.cores = threads)
names(compara_matched_list) <- species_list

# Save R data
save.image(paste0(tf, "_max", maxgap, "min", minovl, "_",alignment_type,"_", matchType,args$label, "_peakConservation.RData"))
