#!/usr/bin/env Rscript
# 2020.01 Huayun
# This script is used to process compara query outputs and overlaps them with genomic regions of interests

# update 2022.11 Huayun
# minor change in associating the conservation statues vector "out" with original peaks. Now matches by peak name 
# minor change added parallel support
# for 4 species, ~50K peaks each, runs with 12 cores, uses ~10G ~3mins


suppressPackageStartupMessages(library(GenomicRanges))
suppressPackageStartupMessages(library(tidyverse))
suppressPackageStartupMessages(library(optparse))
suppressPackageStartupMessages(library(parallel))


# parse arguments ---------------------------------------------------------
option_list <- list(
  make_option(c("-i", "--input-file"), 
              help="Input file specifiying species, path to compara output, and path to peak files "),
  make_option(c("-f", "--factor"),  
                help="The TF/factor being analyzed"),
  make_option(c("-m","--maxmin"), default = "0:1", help="Maxgap:Mininum overlap between orthologous regions and peaks, in bp [default %(default)s]"),
  make_option(c("-s", "--stitchbp"),type="integer", default=2, 
              help="Stitching orthologous regions within how many bps [default %(default)s]"),
  make_option(c("-p", "--return-num-paralogs"), action = "store_true", default = FALSE,
              help = "If to return the number of paralogous regions"),
  make_option(c("-t", "--threads"), default = 4,
              help = "number of threads to use")
              
)
opt_parser <- OptionParser(option_list=option_list)
args <- parse_args(opt_parser)


input_file = args$`input-file`
tf = args$factor
stitchbp = args$stitchbp ## Compara often reports regions with small gaps (1bp). Regions separated by <= stitchbp will be merged
maxgap = as.numeric(unlist(strsplit(args$maxmin, ":"))[1])
minovl = as.numeric(unlist(strsplit(args$maxmin, ":"))[2])

threads = args$threads

return_num_paralogs <- args$return_num_paralogs
return_num_paralogs <- FALSE

# Output argument 
print(args)


# read input file ---------------------------------------------------
print(input_file)
file.table <- read.table(input_file, row.names=1, stringsAsFactors=FALSE) ## Read in table generated by wrapper
colnames(file.table) <- c("compara_out","original_peak")


species_list <- row.names(file.table)


# functions ---------------------------------------------------------------
regions_to_grlist <- function(region_df){
  # Function to parse compara results and summarize the returned region types
  # Parse compara output string to a dataframe
  region_df <- region_df %>% 
    setNames(c("anchor", "other")) %>% 
    mutate(other = strsplit(as.character(other), '\\:')) %>% 
    unnest_legacy(other) %>% 
    separate(other, into = c('species', 'seqnames', "start", "end"), sep = '\\.') %>% 
    mutate(width = as.numeric(start) - as.numeric(end))
  
  # A vector to store the types of orthologous regions
  out <- region_df %>% 
    group_by(anchor) %>% 
    summarise(num_paralogs = as.character(length(species)), width = sum(width), species = paste0(unique(species))) %>% 
    mutate(out = case_when(species == "none" ~ "X",
                           width == 1 & species != "none" ~ "G",
                           TRUE ~ num_paralogs)) %>% 
    dplyr::select(anchor, out) %>% 
    deframe()
  
  # Convert df to granges object  and further split it into a list for fast processing
  region_gr <- makeGRangesFromDataFrame(region_df, keep.extra.columns = T)
  region_gr_list <- GenomicRanges::reduce(split(region_gr, region_gr$anchor, drop = F), min.gapwidth = stitchbp)
  region_gr_list <- region_gr_list[unique(region_gr$anchor)] # reorder
  
  # Get region length after stitching and correct the output
  num_paralogs <- elementNROWS(region_gr_list)
  multi_index <- which(!out %in% c("1", "X", "G"))
  out[multi_index] <- num_paralogs[multi_index]
  
  # reorder out 
  out <- out[unique(region_gr$anchor)]
  
  return(list("ortho_regions" = region_gr_list, "out" = out))
}

# Get a list of compara results.-------------------------------------------------------------------------
# For each species, compara results for other species are stored as lists of GrangesList, which allows multiple hits to be stored. 
# Meanwhile, the EPO outputs are classified into :
# X : EPO returned NA
# D : EPO returned a region of 0 width
# 1:n : number of regions returned by EPO
# The GRangesList and EPO output coding are returned as a named list for easy access 

compara_list <- mclapply(species_list, function(anchor_species){
  print(paste("Processing Compara Regions for:", anchor_species))
  anchor_species_compara <- read.table(file.table[anchor_species,]$compara_out, comment.char="",header=T, stringsAsFactors=FALSE)
  # set all NAs to a dummy region 
  anchor_species_compara[is.na(anchor_species_compara)] <- "none.0.1.0"
  
  # Process all the compara results for the anchor species
  compara_species_process_out <- mclapply(species_list, function(other_species){
    print(other_species)
    other_species_aligned <- anchor_species_compara[, c(1, which(colnames(anchor_species_compara) == other_species))]
    return(regions_to_grlist(other_species_aligned))
    }, mc.cores = threads)
  #compara_species_grs <- lapply(compara_species_process_out, "[[", 1)
  names(compara_species_process_out) <- species_list
  return(compara_species_process_out)
}, mc.cores = threads)
names(compara_list) <- species_list


# Get a list of GRanges for original peaks --------------------------------

original_peaks <- lapply(species_list, function(anchor_species){ ## Read in original peak file. Order is the same as in the compara_regions file
  peaks <- read.table(file.table[anchor_species, "original_peak"], col.names = c("seqnames", "start", "end", "oriPeak")) 
  peaks$oriPeak <- paste0(anchor_species, ".", peaks$oriPeak)
  peak.ranges <- makeGRangesFromDataFrame(peaks, keep.extra.columns = T)
})
names(original_peaks) <- species_list


# Overlap orthologous regions and peaks -------------------------------------------------------------

compara_matched_list <- mclapply(species_list, function(anchor_species){
  print(paste("Processing region match for:", anchor_species))
  
  match_one_species <- mclapply(species_list, function(other_species){
    # function to process each "other species"
    print(paste("Matching regions between: ", anchor_species, other_species))
  
    anchor_species_ori_peaks <- original_peaks[[anchor_species]]
    anchor_species_compara_regions <- compara_list[[other_species]][[anchor_species]]$ortho_regions
    
    other_lift2_anchor <- findOverlaps(anchor_species_ori_peaks, anchor_species_compara_regions, maxgap=maxgap, minoverlap=minovl)
    
    conserved_pks <- as.data.frame(other_lift2_anchor)
    conserved_pks$oriPeak <- names(anchor_species_compara_regions[conserved_pks$subjectHits])

    # For the compara output summary of anchor species projected to other species, saving only X and Gs, and set everything else to 0, meaning EPO alignment found 
    #out <- compara_list[[anchor_species]][[other_species]]$out
    out <- compara_list[[anchor_species]][[other_species]]$out
    out[!out %in% c("X", "G")] <- "0"
    # If the "lifted over" regions overlap with anchor species peaks, label it with 1. 
    out[conserved_pks$queryHits] <- "1"
    
    # For conserved peaks in the "other species", record the number of paralogous regions
    conserved_pks$num_paralogs <- compara_list[[other_species]][[anchor_species]]$out[conserved_pks$oriPeak]
  
    # construct the final output
    species_con_out <- as.data.frame(anchor_species_ori_peaks)["oriPeak"] %>% 
      mutate(index = seq(1:nrow(.)))
    # create a temp column with matching format of peak coordinates: chr.start.end
    species_con_out$tempcol <- gsub(":|-","\\.",gsub("chr","", species_con_out$oriPeak))
    out_df <- enframe(out)
    species_con_out <- left_join(species_con_out, out_df, by = c("tempcol"="name")) %>% 
      #bind_cols(., out = out) %>% 
      left_join(conserved_pks, by = c("index" = "queryHits")) %>%
      rename(ori_peak = oriPeak.x, matched_peaks = oriPeak.y) %>% 
      dplyr::select(-index, -tempcol) %>% 
      group_by(ori_peak) %>% 
      summarise(out = unique(value), matched_peaks = paste(unique(matched_peaks), collapse = ";"), num_paralogs = paste(unique(num_paralogs), collapse = ";")) %>% 
      setNames(.,c("oriPeak",
                   paste0(other_species, "_conStatus"),
                   other_species,
                   paste0("num_paralogs_", other_species)))  
        
    return(species_con_out)
  }, mc.cores = threads)
  match_one_species_out <- match_one_species %>% 
    reduce(left_join, by = "oriPeak") %>% 
    unite("conservation", ends_with("_conStatus"), sep = "") %>% 
    separate(oriPeak, sep = "([\\.\\:\\-])", into = c(NA, "seqnames", "start", "end")) %>% 
    dplyr::select(seqnames, start, end, conservation, !!species_list, everything())
  
  if(!return_num_paralogs){
    match_one_species_out <- match_one_species_out %>% 
      dplyr::select(-starts_with("num_paralogs"))
  }
  
  write.table(x=match_one_species_out,
              file=paste0(tf,"max",maxgap,"min",minovl,"_peakConservation_",anchor_species,".txt"),
              row.names=F, quote=F, sep="\t")
  
  return(match_one_species_out)
}, mc.cores = threads)
names(compara_matched_list) <- species_list

# Save R data
save.image(paste0(tf, "max", maxgap, "min", minovl, "_peakConservation.RData"))
